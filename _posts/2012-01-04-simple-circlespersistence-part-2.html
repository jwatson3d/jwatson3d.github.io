---
layout: post
title: Simple Circles–Persistence (Part 2)
date: '2012-01-04T22:26:00.000-05:00'
author: John
tags:
- Patterns
- Tutorial
- DDD
modified_time: '2012-01-04T22:26:26.866-05:00'
blogger_id: tag:blogger.com,1999:blog-2811308028656623966.post-5051696092472522559
blogger_orig_url: http://pragmatic-software.blogspot.com/2012/01/simple-circlespersistence-part-2.html
---

This post is part of a <a href="http://pragmatic-software.blogspot.com/2012/01/simple-circlesintroduction.html">series</a> on building a simple to use web-based contact and customer relationship management application. The goal is to support various audiences including businesses, teams, clubs, religious organizations, etc. With a basic structure for the domain objects taking shape it’s time to move on to the notion of persistence.<br />One of the tenets of <a href="http://domaindrivendesign.org/resources/what_is_ddd" target="_blank">DDD</a> is known as “aggregate root” – a top-level, course grained collection of responsibilities. In plain object-oriented systems, objects tend to expose granular methods to operate on their data. Unfortunately, this approach allows business knowledge and intimate design details to creep outside of the model. That is, accomplishing a business operation usually entails making several method calls across several objects – this sequencing of calls becomes embedded externally in calling applications making the whole thing tightly coupled and brittle. The aggregate root principle groups related objects closely and provides consistent and coordinated access to these related objects.Vaughn Vernon wrote an in depth three-part article on the topic of <a href="http://domaindrivendesign.org/library/vernon_2011" target="_blank">Effective Aggregate Design</a>.<br />In this model the Party is an obvious root object – we don’t access addresses or notes without first going through the Party instance they belong to. This approach leads to methods like Party.AddAddress() or Party.AddNote() rather than creating addresses and notes separately.<br />Once the aggregate root(s) have been identified it’s time to move on to persisting the data they contain. The Repository pattern is a proven way to implement persistence in a storage-neutral manner. There are many references to consult for more information but in the context of DDD, Jak Charlton’s post, <a href="http://devlicio.us/blogs/casey/archive/2009/02/20/ddd-the-repository-pattern.aspx" target="_blank">DDD: The Repository Pattern</a>, is particularly concise and a good starting point for why it is useful. Gabriel Schenker provides another good <a href="http://nhibernate.hibernatingrhinos.com/27/the-repository-pattern" target="_blank">write up</a> with code examples on the NHibernate FAQ. Given that we have a Party aggregate root, we should also have a PartyRepository since each aggregate should be responsible for its own “domain” or “scope” if you will.<br />Since repositories manage aggregate roots and their associated entities/ values, the basic semantics for the repository follow that of a generic collection. For us this means something like:<br /><pre class="c-sharp" name="code">namespace Circles.Persistence<br />{<br />  using System;<br />  using System.Collections.Generic;<br /><br />  public interface IPartyRepository<br />  {<br />    IList&lt;Party&gt; FindAllParties();<br />    Party FindPartyById(Guid Id);<br />    Guid Add(Party party);<br />    void Delete(Guid Id);<br />    void Update(Party party);<br />  }<br />}</pre><br />Some might balk at the Delete and Update methods, arguing that pure collections have “Remove” instead. However, I am of the opinion that we’re working with domain (a.k.a. business) entities that are persisted <em>somewhere</em> so the semantics of persisting data are more natural with delete and update.<br /><br />Of course the above approach is very "party-specific” so it could be refactored using generics like this:<br /><pre class="c-sharp" name="code">namespace Circles.Persistence<br />{<br />  using System;<br />  using System.Collections.Generic;<br /><br />  public interface IRepository&lt;T&gt; where T : Entity<br />  {<br />    IList&lt;T&gt; FindAll();<br />    T FindById(Guid Id);<br />    Guid Add(T entity);<br />    void Delete(Guid Id);<br />    void Update(T entity);<br />  }<br />}</pre><br />Now we’ve got an interface that supports any type of domain entity – note the removal of the term “Party” from the method names.<br /><br />The above refactored interface implies that every repository created supports all four “CRUD” operations.&nbsp; A better approach would be to split out the operations and then have a specific repository implement the ones it needs like this:<br /><pre class="c-sharp" name="code">namespace Circles.Persistence<br />{<br />  using System;<br />  using System.Linq;<br /><br />  public interface IRepository&lt;T, in TId&gt; where T : Entity<br />  {<br />    T this[TId id] { get; set; }<br />    IQueryable&lt;T&gt; FindAll();<br />    T FindById(TId Id);<br />  }<br /><br />  public interface ISupportSave&lt;in T, out TId&gt; where T : Entity<br />  {<br />    TId Add(T entity);<br />    void Update(T entity);<br />  }<br /><br />  public interface ISupportDelete&lt;T, in TId&gt; where T : Entity<br />  {<br />    void Delete(TId Id);<br />  }<br /><br />  public interface IPartyRepository : IRepository&lt;Party, Guid&gt;, ISupportSave&lt;Party, Guid&gt;, ISupportDelete&lt;Party, Guid&gt;<br />  {<br />    IQueryable&lt;Household&gt; FindAllHouseholds();<br />    IQueryable&lt;Organization&gt; FindAllOrganizations();<br />    IQueryable&lt;Person&gt; FindAllPersons();<br />  }</pre><br />Now we’re explicit about what the PartyRepository does. By implementing IRepository, ISupportSave and ISupportDelete we’re clear that the IPartyRepository supports full CRUD behavior using Guids for the Id types. Additionally, we provide FindAllxxx methods for retrieving specific types from the repository. Notice that having the repository return IQueryable gives flexibility on both sides – concrete implementations can translate the LINQ query passing it to the underlying data store for execution and callers can query the repository in various ways rather than being forced to go through a rigid, narrowly defined API we provide.<br /><br />One more thing to cover – I slipped in a new Type called Entity that is a base class for all domain entities. Rather than rehashing all the details here I’d suggest checking out Jason Dentler’s <a href="http://www.jasondentler.com/blog/" target="_blank">blog</a> or his book <a href="http://www.blogger.com/%3Ca%20href=%22http://www.amazon.com/gp/product/184951304X/ref=as_li_tf_tl?ie=UTF8&amp;tag=wsl-20&amp;linkCode=as2&amp;camp=1789&amp;creative=9325&amp;creativeASIN=184951304X%22%3ENHibernate%203.0%20Cookbook%3C/a%3E%3Cimg%20src=%22http://www.assoc-amazon.com/e/ir?t=wsl-20&amp;l=as2&amp;o=1&amp;a=184951304X%22%20width=%221%22%20height=%221%22%20border=%220%22%20alt=%22%22%20style=%22border:none%20!important;%20margin:0px%20!important;%22%20/%3E" target="_blank">NHibernate 3.0 Cookbook</a>. Equally important is Billy McCafferty’s work on <a href="https://github.com/sharparchitecture/sharp-architecture" target="_blank">Sharp Architecture</a>. Standing on the shoulder’s of giants…<br /><br />The source code for this article can be downloaded from <a href="http://simplecircles.codeplex.com/SourceControl/changeset/changes/c1f3115cfdf3" target="_blank">here</a>.<br /><br />Next we’ll look at testing what we have xUnit.