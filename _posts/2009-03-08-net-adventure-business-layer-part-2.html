---
layout: post
title: ".NET Adventure - Business Layer (part 2)"
date: '2009-03-08T19:06:00.000-04:00'
author: John
tags:
- Patterns
- Tutorial
- OSS
modified_time: '2010-09-06T12:50:54.866-04:00'
thumbnail: http://lh6.ggpht.com/_BvH8o_BvG-4/TIUb5p0eWDI/AAAAAAAAAKM/Ctix-w3aCcs/s72-c/NAdv14.BusinessObject.CustomerBO.Cla%5B2%5D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-2811308028656623966.post-6015215407904720074
blogger_orig_url: http://pragmatic-software.blogspot.com/2009/03/net-adventure-business-layer-part-2.html
---

<p>This post is part of a <a href="http://pragmatic-software.blogspot.com/2009/01/building-complex-net-application.html">series</a> on building a complex .NET application from scratch. In part <a href="http://pragmatic-software.blogspot.com/2009/02/net-adventure-business-layer-part-1.html">1</a> I introduced business entities and refactored code out of the data layer. Now I'm going to build out the business logic and add unit tests to support it.</p> <p><a href="http://lh4.ggpht.com/_BvH8o_BvG-4/TIUb4SMhOvI/AAAAAAAAAKI/hahsXF2KXiM/s1600-h/NAdv14.BusinessObject.CustomerBO.Cla%5B1%5D.png"><img style="border-right-width: 0px; margin: 0px 0px 5px 5px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" border="0" alt="NAdv14.BusinessObject.CustomerBO.ClassDiagram" align="right" src="http://lh6.ggpht.com/_BvH8o_BvG-4/TIUb5p0eWDI/AAAAAAAAAKM/Ctix-w3aCcs/NAdv14.BusinessObject.CustomerBO.Cla%5B2%5D.png?imgmax=800" width="244" height="148"></a> A new BusinessObject project (assembly) has been created and a CustomerBO class added to the project. This class contains the business logic for the customer domain entity. The class diagram for this CustomerBO is shown on the right. As the diagram indicates there are methods to get a customer instance as well as store one. In the case of GetCustomer() an instance of the Customer business entity previously described is returned with fully populated attributes. StoreCustomer() takes a Customer entity instance previously populated by a client layer and passes it to the appropriate data access object for storage.</p> <p><a href="http://lh6.ggpht.com/_BvH8o_BvG-4/TIUb5_2FCmI/AAAAAAAAAKQ/C-FsXps8t3k/s1600-h/NAdv14.BusinessObject.CustomerBO3.png"><img style="border-right-width: 0px; margin: 0px 5px 5px 0px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" border="0" alt="NAdv14.BusinessObject.CustomerBO" align="left" src="http://lh5.ggpht.com/_BvH8o_BvG-4/TIUb68EcgZI/AAAAAAAAAKU/NcAHZzA27wc/NAdv14.BusinessObject.CustomerBO_thu.png?imgmax=800" width="244" height="232"></a> Looking at the code shown on the left, the red arrow coming in from the left side indicates where an external caller would call in to the CustomerBO class to retrieve a customer instance. The additional parameter <em>includeAddress</em> allows the caller to control how "deep" the retrieval goes. If only basic customer attributes are needed then setting <em>includeAddress</em> to false will return just the "primary" attributes. However, setting <em>includeAddress</em> to true will cause the customer business object to populate associated addresses by passing the customer instance to LoadAddresses. The LoadAddresses method invokes the GetAddresses method which returns the list of associated addresses and then LoadAddresses sets the customer entity's Addresses property to the result.</p> <p>Since a customer address doesn't have business meaning outside of a customer I've decided not to expose a Customer Address business object. Instead, the few needed methods for manipulating the addresses have been added to the Customer business object. As the code shows, the object is "smart enough" to retrieve, set, and store associated addresses.</p> <p>Notice that the Customer business entity (a.k.a.the data transfer object) is passed by the CustomerBO business object to the CustomerDAO data access object. The data access object "knows" how and where to persist the attributes of a customer, including the associated addresses. Another approach might be to have the business object, CustomerBO in this case, decompose the business entity and make decisions regarding what to store. Doing so introduces other side effects such as the business layer needing to manage transactional semantics when called upon to store information. That is, if the business object decomposes a Customer entity into its component parts - a Customer and a CustomerAddress - it will have to invoke the data access layer twice, once to store the customer and a second call to the CustomerAddressDAO to store its data. In the event of a failure, the database could be left in an indeterminate state. The usual way to handle this possibility is to wrap both calls inside a transaction. This causes the business objects to have references to and use a transaction manager. The real question is does transactional storage semantics belong up in the business layer or down in the data layer.</p> <p>Now that the original data layer has been refactored we can return to the unit tests. Firstly, the DataLayer tests have been updated slightly to create instances of a Customer business entity and pass to the CustomerDAO methods. A second set of tests have been added to test the business layer. Once again, by taking the time early on to put the testing framework into place, it is reaping rewards every time we make a change to the code. We're able to exercise each layer as we go and ensure that all the moving parts line up correctly.</p> <p>The code for this version of the project can be downloaded <a href="http://docs.google.com/a/wrbsoftware.com/uc?id=0B0Ogd3bGXPjJZmE2NDc4ZmUtNGE2YS00MTJlLWJhODctZjQ1MzY5ODg2MjYx&amp;export=download&amp;authkey=CJHo9bQC&amp;hl=en"><strong>here</strong></a>. You'll find the new Business Object project as well as updated unit tests.</p>  