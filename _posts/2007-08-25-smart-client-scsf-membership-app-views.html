---

title: Smart Client (SCSF) Membership App - Views
date: '2007-08-25T13:55:00.000-04:00'
author: John
tags:
- CAB/SCSF
modified_time: '2010-09-05T19:56:41.771-04:00'
thumbnail: http://lh5.ggpht.com/_BvH8o_BvG-4/TIQuMpWCCjI/AAAAAAAAAH8/mczJ-q6efeI/s72-c/GS_PersonTabView_thumb%5B1%5D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-2811308028656623966.post-885490406473899623
blogger_orig_url: http://pragmatic-software.blogspot.com/2007/08/smart-client-scsf-membership-app-views.html
---

<p>This post is part of a series which discusses the journey I took building a smart client membership application using Microsoft's <a href="http://web.archive.org/web/20080215200904/http://msdn2.microsoft.com/en-us/library/aa480482.aspx">Smart Client Software Factory</a> (SCSF). You can navigate the entire series from <a href="http://pragmatic-software.blogspot.com/2007/08/building-smart-client-application-using.html">here</a>.  <p>Views are probably the easiest artifact for smart client developers to understand and build. The fact that views are implemented as user controls and that there are recipes for generating them only lend to their ease of use. Finally, there is a lot of documentation and good diagrams about views to peruse. Even the model-view-presenter (MVP) paradigm is pretty well known or at least accessible with all the information available. What is perhaps a bit trickier is how to make multiple views work in concert <em>within the SCSF architecture of shells, work items, and controllers</em>.  <p><a href="http://lh3.ggpht.com/_BvH8o_BvG-4/TIQuMAL2z8I/AAAAAAAAAH4/9lj3UyFR-BY/s1600-h/GS_PersonTabView%5B4%5D.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; margin-left: 0px; border-top: 0px; margin-right: 0px; border-right: 0px" title="GS_PersonTabView" border="0" alt="GS_PersonTabView" align="left" src="http://lh5.ggpht.com/_BvH8o_BvG-4/TIQuMpWCCjI/AAAAAAAAAH8/mczJ-q6efeI/GS_PersonTabView_thumb%5B1%5D.png?imgmax=800" width="244" height="189"></a> In this article, I will be dissecting the Person views show in the left screenshot. The Members project tree<a href="http://lh6.ggpht.com/_BvH8o_BvG-4/TIQuNby0xQI/AAAAAAAAAIA/6HMNs8kyL-c/s1600-h/MemberProjectTree%5B4%5D.png"><img style="border-bottom: 0px; border-left: 0px; display: inline; margin-left: 0px; border-top: 0px; margin-right: 0px; border-right: 0px" title="MemberProjectTree" border="0" alt="MemberProjectTree" align="right" src="http://lh3.ggpht.com/_BvH8o_BvG-4/TIQuN067c_I/AAAAAAAAAIE/mLAHOJe1NW0/MemberProjectTree_thumb%5B1%5D.png?imgmax=800" width="137" height="244"></a>  shown on the right currently contains four view folders - two for Person and two for Household. These views were generated using the "Add View (with presenter)" recipe and then customized as needed. For the list views, I used the SmartPart Quickstart that comes with the SCSF installation as a basis for my lists. I chose the Windows.Forms.ListView control as I want to be able to show a richer user interface that's more intuitive such as showing each household in a tree view with the individual persons listed as sub-items underneath the household. I'd also like as much "free-form" navigation as possible. For example, selecting a person from the aforementioned tree-view will display that person's information even though the user has currently navigated to households. The relationship between people and households is so great that it doesn't make sense from an application perspective to force the user to always navigate by going to the menu or toolbar. Seeing a list of households and the people associated, it's natural to want to click on the person and navigate to manage that person's information. This kind of flexibility is more easily met using the ListView as the basis of the work.  <p>The PersonListView shown running in the above screenshot is displayed via a command handler that is wired up to the 'People" menu item and toolbar button. Here's the code that causes the view to be displayed:<pre class="csharp" name="code">  [CommandHandler(CommandNames.ManagePersons)]<br />  public void ManagePersonsHandler(object sender, EventArgs e)<br />  {<br />      ShowViewInWorkspace&lt;PersonListView&gt;(WorkspaceNames.LeftWorkspace);<br />  }</pre><br /><p>The MVP pattern is implemented for you by the recipe-generated code. When the view is created a presenter instance is also created and made available as a property of the view class:<pre class="csharp" name="code">  [SmartPart]<br />  public partial class PersonListView<br />  {<br />      /// &lt;summary&gt;<br />      /// Sets the presenter. The dependency injection system<br />      /// will automatically create a new presenter for you.<br />      /// &lt;/summary&gt;<br />      [CreateNew]<br />      public PersonListViewPresenter Presenter<br />      {<br />          set<br />          {<br />              _presenter = value;<br />              _presenter.View = this;<br />          }<br />      }<br />  }</pre><br /><p>Following the MVP pattern, the view should only be concerned with displaying the information it is given without knowledge of anything else the application might have available to it or be doing. To help with this the view's OnLoad() method signals that it is "ready" by calling over to the presenter's OnViewReady() method:<pre class="csharp" name="code">  protected override void OnLoad(EventArgs e)<br />  {<br />      _presenter.OnViewReady();<br />      base.OnLoad(e);<br />  }</pre><br /><p>The presenter's code is where the action takes place - it "contacts" the model, in this case by calling the _memberSvc.GetPersonList() method, to get the data and then gives that data to the view via the View.SetPersons() method:<pre class="csharp" name="code">  [ServiceDependency]<br />  public MemberService MemberService<br />  {<br />      set { _memberSvc = value; }<br />  }<br /><br />  /// &lt;summary&gt;<br />  /// This method is a placeholder that will be called<br />  /// by the view when it has been loaded.<br />  /// &lt;/summary&gt;<br />  public override void OnViewReady()<br />  {<br />      base.OnViewReady();<br />      LoadPersons();<br />  }<br /><br />  private void LoadPersons()<br />  {<br />      PersonListItemCollection persons = _memberSvc.GetPersonList();<br />      if (persons != null)<br />      {<br />          View.SetPersons(persons);<br />      }<br />  }</pre><br /><p>Note that the MemberService is filling the role of the model and will be discussed in another article. The view's SetPersons() method was taken almost verbatim from the SmartPart QuickStart and is responsible for taking data and rendering it:<pre class="csharp" name="code">  #region IPersonListView Members<br /><br />  void IPersonListView.SetPersons(PersonListItemCollection persons)<br />  {<br />      Guard.ArgumentNotNull(persons, "persons");<br />      InnerSetPersons(persons);<br />  }<br /><br />  #endregion<br /><br />  private void InnerSetPersons(PersonListItemCollection persons)<br />  {<br />      List&lt;ListViewItem&gt; toRemove = new List&lt;ListViewItem&gt;();<br /><br />      foreach (ListViewItem item in _personListView.Items)<br />      {<br />          PersonListItem listPerson = PersonMapper.FromListViewItem(item);<br />          int index = persons.IndexOfId(listPerson.ContactId.Value);<br />          if (index &gt; -1)<br />              toRemove.Add(item);<br />          else<br />              persons.Remove(persons[index]);<br />      }<br /><br />      toRemove.ForEach(delegate(ListViewItem lvi) { _personListView.Items.Remove(lvi); });<br />      foreach (PersonListItem person in persons)<br />          _personListView.Items.Add(PersonMapper.ToListViewItem(person));<br />  }</pre><br /><p>The next part to look at is how users interact with the views. When a person shown in the list view is clicked, the right-hand workspace should show that person's details. To accomplish this we must fall back on the "formula" for MVP - the view is only concerned with rendering the data. The PersonListView therefore does not "know" what to do with the click - the selected person is displayed elsewhere (outside the view) by another part of the application. To accomplish this separation of concerns, the initial Windows Forms event (that is, the on click handler) needs to be translated into a CAB Event that is published to the world (okay, the rest of the application) to be handled elsewhere:<pre class="csharp" name="code">  private void personListView_SelectedIndexChanged(object sender, EventArgs e)<br />  {<br />      if (_personListView.SelectedItems.Count == 0)<br />          return;<br /><br />      //Pass the event directly to the presenter to handle<br />      PersonListItem person = PersonMapper.FromListViewItem(_personListView.SelectedItems[0]);<br />      _presenter.ShowPersonDetails(person.ContactId.Value);<br />  }</pre><br /><p>Remember the MVP pattern has all three pieces working together so the view simply passes the action on to the presenter to take care of by calling the presenter's ShowPersonDetails() method. It is here in the presenter's method that the user's action is converted to a CAB event and published:<pre class="csharp" name="code">  [EventPublication(EventTopicNames.ShowPersonDetails, PublicationScope.Global)]<br />  public event EventHandler&lt;EventArgs&lt;int&gt;&gt; ShowPersonDetailsHandler;<br /><br />  public void ShowPersonDetails(int contactId)<br />  {<br />      //To maintain a separation of concerns publish an event to be handled elsewhere<br />      if (ShowPersonDetailsHandler != null)<br />          ShowPersonDetailsHandler(this, new EventArgs&lt;int&gt;(contactId));<br />  }</pre><br /><p>We know we want to display the person's details on the right-hand workspace but the trick is where to place that code and how to make it happen. I jumped the gun in the previous article about work items by showing the logic for creating a person work item and kicking it off. The full code for this is in the ModuleController.cs class. The reason it is there is one of logical grouping and hierarchy of responsibility/ownership. The coarse hierarchy is Shell -&gt; Members_Module -&gt; Child_Work_Items and since the PersonListView is displayed by the module during the menu command handling event, it is the module that "owns" the view (actually, "owns" the model-view-presenter trio). Therefore, when the presenter raises the ShowPersonDetails event, it is best to put that code as close to where it is related while going back up the "chain". Since the Members module contains all things relating to members and since the PersonListView is owned and managed by that module (actually, that module's ModuleController) then the next step back up the chain from the presenter is the ModuleController - remember that the module controller is a specialized work item. So the proper place to <em>scope</em> the event (see previous post about work items being a scoping container) is the next work item up the chain which is also the work item for the entire module. Here is the code in the ModuleController.cs that responds to the CAB Event:<pre class="csharp" name="code">  [EventSubscription(EventTopicNames.ShowPersonDetails, ThreadOption.UserInterface)]<br />  public void OnShowPersonDetails(object sender, EventArgs&lt;int&gt; eventArgs)<br />  {<br />      int personId = eventArgs.Data;<br /><br />      //Create a key for the workitem so we can check<br />      //later if the workitem has already been created.<br />      string key = "Person" + personId;<br /><br />      PersonWorkItem workItem = WorkItem.WorkItems.Get&lt;PersonWorkItem&gt;(key);<br /><br />      if (workItem == null)<br />      {<br />          // add a new work item representing this instance to<br />          // to the collection of work items in this module<br />          workItem = WorkItem.WorkItems.AddNew&lt;PersonWorkItem&gt;(key);<br />                <br />          // add a new detail view smart part to the collection of smart parts<br />          workItem.SmartParts.AddNew&lt;PersonDetailView&gt;("PersonDetailView");<br />          workItem.SmartParts.AddNew&lt;PersonChannelsView&gt;("PersonChannelsView");<br /><br />          workItem.Run(personId, WorkItem.Workspaces[WorkspaceNames.RightWorkspace]);<br />      }<br />      else<br />          workItem.Activate();<br />  }</pre><br /><p>At first there appears to be a lot going on but it boils down to creating a PersonWorkItem instance for the selected person and then "running" the work item that is, telling it the workspace to display its views in. One thing I discovered the hard way through lots of Google "digging" is that if you're using SmartPartPlaceholders on a view you need to ensure the smart parts that are going to be displayed in the placeholders already exist in the SmartParts collection before the view is shown. This is why I'm manually creating the detail and contact channel views and adding them to the collections before the work item's Run method is called. Here is what the PersonWorkItem's Run() method looks like:<pre class="csharp" name="code">  public void Run(int PersonId, IWorkspace ContentWorkspace)<br />  {<br />      Run();<br /><br />      // save the Person data in the work item<br />      Person person = _memberSvc.GetPerson(personId);<br />      Items.Add(person, "Person");<br />            <br />      // create a person tab view and show it<br />      tabView = SmartParts.AddNew&lt;PersonTabView&gt;();<br />      TabSmartPartInfo tabInfo = new TabSmartPartInfo();<br />      tabInfo.Title = person.FullName;<br />      tabInfo.ActivateTab = true;<br />      ContentWorkspace.Show(tabView, tabInfo);<br />  }</pre><br /><p>As you can see above, the person id is passed in and used to retrieve the Person instance. Note that this person instance data is stored in the work item's Items collection - not in it's State. Unfortunately, lots of examples show how easy it is to use the [State] attribute on a property to automagically copy the data from the work item state into the view's property member. This is bad. The state bag is for persistence of data across invocations of the application and it is type-less. That means everything has to be cast and value types are boxed/unboxed which is not the best performing thing to do. The Items collection is a .NET 2.0 generic collection that was specifically designed for holding things, a.k.a. "items". It is easily accessed in views and presenters using the WorkItem property that refers to the work item they are contained in. I confess that I did the bad thing first, using the same examples and documentation but it became harder to follow and manage and I soon found several posts saying using the State was bad, okay it wasn't optimal or necessary if you weren't planning on saving it. Instead of coding your property using the [State] attribute you should do this:<pre class="csharp" name="code">  public Person Person<br />  {<br />      get { return WorkItem.Items.Get&lt;Schema.Person&gt;("Person"); }<br />  }</pre><br /><p>In summary, I've talked about views, the MVP pattern and how it's implemented, where to put logic, how to convert user events into CAB Events and "catch" them elsewhere, how the work items are brought into play and how to bring it all together. In the next article I'll go into details about the service layer and how it's implemented. <br /><p><a href="http://geekswithblogs.net/jwatson/archive/2007/08/25/114962.aspx"><font size="1">Original post</font></a></p>  