---
layout: post
title: ".NET Adventure - Business Layer (part 1)"
date: '2009-02-09T05:15:00.000-05:00'
author: John
tags:
- Patterns
- Tutorial
- OSS
modified_time: '2010-09-06T12:44:59.809-04:00'
thumbnail: http://lh6.ggpht.com/_BvH8o_BvG-4/TIRFoGoNjmI/AAAAAAAAAIM/ZNI_cMHk3gs/s72-c/RefAppArch_thumb3.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-2811308028656623966.post-6397896807395517512
blogger_orig_url: http://pragmatic-software.blogspot.com/2009/02/net-adventure-business-layer-part-1.html
---

<p>This post is part of a series on building a complex.NET application from scratch. In Parts <a href="http://pragmatic-software.blogspot.com/2009/01/net-adventure-data-layer-part-1.html">1</a>, <a href="http://pragmatic-software.blogspot.com/2009/01/net-adventure-data-layer-part-2.html" target="_blank">2</a>, and <a href="http://pragmatic-software.blogspot.com/2009/01/net-adventure-data-layer-part-3.html" target="_blank">3</a>, I introduced the data layer along with tools like <a href="http://nunit.org/" target="_blank">NUnit</a>, <a href="http://nant.sourceforge.net/" target="_blank">NAnt</a>, and <a href="http://go.microsoft.com/fwlink/?LinkId=70294" target="_blank">FxCop</a> to round out the project development. Today I'm going to cover the first part of the entity layer.</p> <p><a href="http://lh6.ggpht.com/_BvH8o_BvG-4/TIRFnNT14uI/AAAAAAAAAII/1nE6_aVdiTk/s1600-h/RefAppArch5.png"><img style="border-right-width: 0px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" border="0" alt="RefAppArch" align="right" src="http://lh6.ggpht.com/_BvH8o_BvG-4/TIRFoGoNjmI/AAAAAAAAAIM/ZNI_cMHk3gs/RefAppArch_thumb3.png?imgmax=800" width="375" height="354"></a> Having made a first pass at the data layer in previous posts, I'm going to move up to the business layer and begin working there. Recall the Common Application Architecture diagram from <a href="http://www.codeplex.com/AppArchGuide/Wiki/View.aspx?title=Chapter%203%20-%20Architecture%20and%20Design%20Guidelines" target="_blank">Chapter 3</a> of Microsoft's <a href="http://www.codeplex.com/AppArchGuide/Wiki/View.aspx?title=Home" target="_blank">Application Architecture Guide 2.0</a> shown here. Whereas the data layer used the <a href="http://en.wikipedia.org/wiki/Active_record_pattern" target="_blank">Active Record</a> pattern to model or "wrap" each table as a class with <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_blank">CRUD</a> methods for persisting to/from the underlying table, the business layer decomposes the work into up to four separate components tailored to specific purposes.</p> <p>Generally speaking, the business layer is where the domain rubber meets the binary road - that is, you typically implement the domain model and logic there. It's called the "business" layer for good reason - it's the business view of the application. While you may have normalized the data storage to <a href="http://en.wikipedia.org/wiki/3NF" target="_blank">3NF</a> such that <a href="http://en.wikipedia.org/wiki/E.F._Codd" target="_blank">E.F. Codd</a> would be proud were he still here, the business view of data is typically courser grained and models business or "real world" entities. For example, in <a href="http://www.codeplex.com/MSFTDBProdSamples/Wiki/View.aspx?title=AWLTDocs" target="_blank">AWLT</a> we have a Customer table and a Customer Address table which translates into two separate classes in our data layer according to the rules of the Active Record pattern. However, a business view would consider them a single Customer entity having properties of name, email address, etc. <strong>*and*</strong> one or more addresses.</p> <p><a href="http://lh4.ggpht.com/_BvH8o_BvG-4/TIRPphBpDKI/AAAAAAAAAJ4/iJ_RRrWcPgk/s1600-h/NAdv.DataLayer_customer1.png"><img style="border-right-width: 0px; margin: 0px 0px 5px 5px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" border="0" alt="NAdv.DataLayer_customer" align="right" src="http://lh4.ggpht.com/_BvH8o_BvG-4/TIRPrxfE9CI/AAAAAAAAAJ8/Aj3ASZrWje8/NAdv.DataLayer_customer_thumb.png?imgmax=800" width="176" height="268"></a> In the previous version the Data Layer defined a classic business object containing data and logic as shown on the right. Notice that there are a number of instance methods (without underlines) such as Load and Store that operate on the instance data contained within the object. However, we're going to refactor the properties out to a separate entity and make the data access object contain logic only.</p> <p>The Business Entities component is where you define these entities and the Business Components is where you implement the business logic. This separation of logic and data is different from a classic <a href="http://en.wikipedia.org/wiki/Business_object_(computer_science)" target="_blank">business object</a> where the data and object are encapsulated in a single class. In a layered architecture the data will need to be accessed in several places so it is usually split out into its own Business Entity component thus the <a href="http://en.wikipedia.org/wiki/Data_Transfer_Object" target="_blank">Data Transfer Object</a> pattern serves the purpose of defining entities that can be shared between parts of the system.</p> <p><a href="http://lh3.ggpht.com/_BvH8o_BvG-4/TIRPsgIQV9I/AAAAAAAAAKA/QjGrtd1SG_s/s1600-h/NAdv.BusinessEntity.Customer.png"><img style="border-right-width: 0px; margin: 0px 10px 5px 0px; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" border="0" alt="NAdv.BusinessEntity.Customer" align="left" src="http://lh3.ggpht.com/_BvH8o_BvG-4/TIRPwMqSgaI/AAAAAAAAAKE/InUKFo_SWxc/NAdv.BusinessEntity.Customer_thumb.png?imgmax=800" width="203" height="271"></a> Notice on the left diagram there are now two classes in separate packages. First there's a new Customer class in the BusinessEntity package containing only properties (just a few are shown here). DTOs are pretty light weight - a public class with public properties that's marked as serializable. Second the data layer class formerly known as "Customer" has been refactored to CustomerDao since it is now a true data access object. The properties have been moved out and the methods are now all static since they no longer have instance data with which to work. Finally, note that several methods such as Load and Store accept a Customer instance as a parameter. Previously we would create an instance of the data layer class, set its properties and then invoke its methods to persist. Now we create an instance of the Customer entity, fill its properties and pass that instance to the Dao class to persist it.</p> <p>The business entity classes can be implemented in different ways. First, they can simply be a sub folder within in a single business layer project perhaps with a separate namespace (e.g. NAdv.BusinessLayer.BusinessEntity) that is compiled into a single Business Layer assembly. The problem with this approach is that any other part of the application that needs to use a business entity (such as shown with the data layer above) must reference <em>and have access to at runtime</em> the business layer assembly. The further implication is that the presentation layer which "consumes" these business entities could reside on a Windows client machine and would need a copy of the business layer installed locally in order to "receive" the data from the service layer. Another way to implement business entities is to place them into their own assembly, which I've done.</p> <p>The code for this version of the project can be downloaded <a href="http://docs.google.com/a/wrbsoftware.com/uc?id=0B0Ogd3bGXPjJMGQ2NTc4ODctYTg4Yy00YTNkLTg5ZmMtYTkxOWI0ODU2YzBl&amp;export=download&amp;authkey=CLKru0E&amp;hl=en">here</a>. You'll find the new BusinessEntity project, the refactored DataLayer project and the updated unit tests.</p>  