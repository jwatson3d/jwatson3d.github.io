---
layout: post
title: Simple Circles–NHibernate Unit Testing (Part 7c)
date: '2012-02-19T22:29:00.001-05:00'
author: John Watson
excerpt: In Part 7a I implemented the Repository pattern using NHibernate and in Part 7b I used Fluent NHibernate to implement the Data Mapper pattern between the domain layer and the relational database layer. In this post I’ll build unit tests to exercise these implementations.
tags:
- Patterns
- Tutorial
- TDD
- NHibernate
- OSS
modified_time: '2012-02-19T22:29:09.465-05:00'
blogger_id: tag:blogger.com,1999:blog-2811308028656623966.post-1211037300635528562
blogger_orig_url: http://pragmatic-software.blogspot.com/2012/02/simple-circlesnhibernate-unit-testing.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">This post is part of a <a href="http://pragmatic-software.blogspot.com/2012/01/simple-circlesintroduction.html">series</a> on building a simple to use web-based contact and customer relationship management application. The goal is to support various audiences including businesses, teams, clubs, religious organizations, etc.<br /><br />In <a href="/simple-circlesnhibernate-repository/">Part 7a</a> I implemented the Repository pattern using NHibernate and in <a href="/simple-circlesnhibernate-mapping-part/">Part 7b</a> I used Fluent NHibernate to implement the Data Mapper pattern between the domain layer and the relational database layer. In this post I’ll build unit tests to exercise these implementations.<br /><br />One of the problems with attempting to test a data access strategy is ensuring the database is in a known state at the start of each test. Previously I’ve used teardown and setup SQL scripts to empty out data and preload initial values in a database instance. That approach is tedious because it means maintaining two sets of scripts in a different syntax (SQL instead of C#) and using a different toolset (SSMS). Another approach that’s becoming more popular and prevalent is to use a lighter footprint database engine capable of running in-memory. In fact, Fluent NHibernate makes this easy with its standard configuration – all it takes is setting up an NHibernate session configured to use the in-memory database as shown here:<br /><br /><span style="font-size: large;">SessionFactory Class</span><br /><pre class="c-sharp" name="code">namespace Circles.NHibernateTests<br />{<br />  using Circles.NHibernateRepository;<br /><br />  using FluentNHibernate.Cfg;<br />  using FluentNHibernate.Cfg.Db;<br /><br />  using NHibernate;<br />  using NHibernate.Cfg;<br />  using NHibernate.Tool.hbm2ddl;<br /><br />  public class SessionFactory<br />  {<br />    private static Configuration staticConfig;<br /><br />    public static ISessionFactory CreateSessionFactory()<br />    {<br />      return<br />        Fluently.Configure()<br />          .Database(SQLiteConfiguration.Standard.InMemory().ShowSql())<br />          .Mappings(m =&gt; m.FluentMappings.AddFromAssemblyOf&lt;PartyRepository&gt;().ExportTo(System.Console.Out))<br />          .ExposeConfiguration((c) =&gt; staticConfig = c)<br />          .BuildSessionFactory();<br />    }<br /><br />    public static void BuildSchema(ISession session)<br />    {<br />      var export = new SchemaExport(staticConfig);<br />      export.Execute(script: true, export: true, justDrop: false, connection: session.Connection, exportOutput: null);<br />    }<br />  }<br />}</pre>Lines 20-22 contain all the “magic”: line 20 configures the database to use the standard in-memory configuration for SQLite. Line 21 sets up the mappings to be read from the <span style="font-family: 'Courier New', Courier, monospace;">PartyRepository</span> assembly; in addition, the ExportTo() method call will dump the generated hbm.xml to the console. Line 22 exposes the configuration being set up before it is passed to NHibernate for session creation. In this case, the Lambda expression stores the newly built configuration in a static variable for later reuse by the BuildSchema method.<br /><br />xUnit does not implement or use constructs such as <span style="font-family: 'Courier New';">[Setup]</span> / <span style="font-family: 'Courier New';">[Teardown]</span> like nUnit does or <span style="font-family: 'Courier New';">[TestInitialize]</span> / <span style="font-family: 'Courier New';">[TestCleanup]</span> like MSTest does since the authors feel it is problematic. You can read more about the rational on James Newkirk’s blog post “<a href="http://jamesnewkirk.typepad.com/posts/2007/09/why-you-should-.html" target="_blank">Why you should not use Setup and TearDown in NUnit</a>”. Pretty compelling when the main author himself tells you not to; however, I’m going to bend the rules a little. I’ve implemented a base testing class that contains a virtual method called <span style="font-family: 'Courier New';">TestInitialize()</span> whose purpose is to prepare the testing database and put it in a known state before each test is executed:<br /><br /><span style="font-size: large;">TestBase Class</span><br /><pre class="c-sharp" name="code">namespace Circles.NHibernateTests<br />{<br />  using NHibernate;<br /><br />  /// &lt;summary&gt;<br />  /// Base class for NHibernate / SQLite tests<br />  /// &lt;/summary&gt;<br />  public abstract class TestBase<br />  {<br />    protected static readonly object LockObject = new object();<br /><br />    private static ISessionFactory sessionFactory;<br /><br />    protected ISession Session { get; set; }<br /><br />    /// &lt;summary&gt;<br />    /// Code to run before the test to allocate <br />    /// and configure any resources needed.<br />    /// &lt;/summary&gt;<br />    public virtual void TestInitialize()<br />    {<br />      sessionFactory = SessionFactory.CreateSessionFactory();<br />      Session = sessionFactory.OpenSession();<br />      SessionFactory.BuildSchema(Session);<br />    }<br /><br />    public void Dispose()<br />    {<br />      Session.Dispose();<br />    }<br />  }<br />}</pre><br />Each test class can now easily prepare an in-memory database and place it in a known state prior to executing tests by overriding <span style="font-family: 'Courier New';">TestInitialize()</span> with its own specific behavior:<br /><br /><span style="font-size: large;">TestInitialize() Method</span><br /><pre class="c-sharp" name="code">public override void TestInitialize()<br />{<br />  Monitor.Enter(LockObject);<br /><br />  base.TestInitialize();<br /><br />  using (var tx = Session.BeginTransaction())<br />  {<br />    var householdType = new PartyType(new Guid(Constants.PartyTypeIdHousehold))<br />    {<br />      TypeName = "Household"<br />    };<br />    Session.Save(householdType);<br /><br />    var personType = new PartyType(new Guid(Constants.PartyTypeIdPerson))<br />    {<br />      TypeName = "Person"<br />    };<br />    Session.Save(personType);<br /><br />    var person = new Person<br />    {<br />      FirstName = "Nancy",<br />      LastName = "Davolio",<br />      Gender = GenderEnum.Female,<br />      Birthday = new DateTime(1948, 12, 8),<br />      PartyType = personType<br />    };<br />    Session.Save(person);<br /><br />    Session.Flush();<br />    tx.Commit();<br />  }<br /><br />  Session.Clear();<br /><br />  Monitor.Exit(LockObject);<br />}</pre><br />The <span style="font-family: 'Courier New';">Monitor.Enter</span> and <span style="font-family: 'Courier New';">Monitor.Exit</span> calls (lines 3 &amp; 38) ensure that access to the NHibernate Session remains serialized and two test methods can’t accidently interfere with each other in multi-threaded harnesses. The first call is to the base class’ implementation which creates the in-memory database. Following that I create PartyType instances for Household and Person and then create and persist a well-known Person instance.<br /><br />With the base class and SessionFactory implemented and in place, constructing unit tests that can exercise (indirectly) the mappings as well as an actual, deployed database layer becomes trivial:<br /><br /><span style="font-size: large;">CanAddHousehold() Test Method</span><br /><pre class="c-sharp" name="code">[Fact]<br />public void CanAddHousehold()<br />{<br />  this.TestInitialize();<br /><br />  IPartyRepository repository;<br />  Household household;<br /><br />  // arrange<br />  using (var tx = Session.BeginTransaction())<br />  {<br />    repository = new PartyRepository(Session);<br />    var partyType = repository.FindPartyTypeById(new Guid(Constants.PartyTypeIdHousehold));<br /><br />    // act<br />    household = new Household<br />    {<br />      PartyName = "Eisenhower",<br />      FormalGreeting = "President Dwight D. and Mrs. Mamie",<br />      InformalGreeting = "Ike and Mamie",<br />      PartyType = partyType<br />    };<br /><br />    repository.Add(household);<br />    tx.Commit();<br />  }<br /><br />  // assert<br />  Assert.NotNull(household);<br />  Assert.NotNull(repository.FindById(household.PartyId));<br />}</pre><br />Line 4 initializes the database including preparing the known state, Line 12 initializes a <span style="font-family: 'Courier New';">PartyRepository</span> instance using the in-memory database session. This particular line of code deserves special attention – I’m creating a <span style="font-family: 'Courier New';">PartyRepository</span> and giving it the in-memory database to operate against. Recall in <a href="http://pragmatic-software.blogspot.com/2012/01/simple-circlesnhibernate-repository.html">Part 7a</a> on Line 47 of the fourth code fragment (<span style="font-family: 'Courier New';">DBSession</span> class)&nbsp; that a <span style="font-family: 'Courier New';">PartyRepository</span> instance was created using the “real” NHibernate <span style="font-family: 'Courier New';">DbSession</span> there. Here’s where designing the NHibernate repository to accept an <span style="font-family: 'Courier New';">ISession</span> implementation gives flexibility.<br /><br />Line 13 retrieves the household party type that is known to be there because it was created and saved during <span style="font-family: 'Courier New';">TestInitialize()</span>. Finally the household is created and saved. An interesting side effect of this test was when I first ran it – it failed. I had forgotten to specify/assign a <span style="font-family: 'Courier New';">PartyType</span> to the household instance. When I referred back to the <a href="http://pragmatic-software.blogspot.com/2012/01/simple-circlesfake-repository-part-3.html">earlier tests</a> that I put together using the FakeRepository I realized that it too wasn’t assigning or checking the party type. This oversight illustrates a problem with trying to fake or mock an implementation – you have to remember to code and test all the validation and business rules necessary to be a “real” repository. This is the best reason to have taken these steps of setting up a reusable, fast way to test the real repository – as you code the repository, you can test it without having to write double the code by updating the fake one.<br /><br />This discovery led to adding a negative test to ensure the repository doesn’t allow a household without a party type:<br /><br /><span style="font-size: large;">Negative Test</span><br /><pre class="c-sharp" name="code">[Fact]<br />public void CanNotAddHouseholdWithMissingPartyType()<br />{<br />  this.TestInitialize();<br /><br />  // arrange<br />  using (var tx = Session.BeginTransaction())<br />  {<br />    var repository = new PartyRepository(Session);<br /><br />    // act<br />    var household = new Household<br />    {<br />      PartyName = "Eisenhower",<br />      FormalGreeting = "President Dwight D. and Mrs. Mamie",<br />      InformalGreeting = "Ike and Mamie",<br />      /* PartyType = partyType */<br />    };<br /><br />    // assert<br />    Assert.Throws&lt;NHibernate.PropertyValueException&gt;(<br />      delegate<br />      {<br />        repository.Add(household);<br />      });<br /><br />    tx.Rollback();<br />  }<br />}</pre><br />Lines 21-25 uses the xUnit <span style="font-family: 'Courier New';">Assert.Throws&lt;&gt;</span> method to wrap the attempt to add a household without a party type. If the repository doesn’t throw an <span style="font-family: 'Courier New';">NHibernate.PropertyValueException</span> then the test is considered to have failed.<br /><br />This post was pretty densely packed with concepts - an entire framework for testing an NHibernate-based data layer. The accompanying code base is growing larger and can be downloaded from <a href="http://simplecircles.codeplex.com/SourceControl/changeset/changes/ce2fb882617b">here</a>.</div>