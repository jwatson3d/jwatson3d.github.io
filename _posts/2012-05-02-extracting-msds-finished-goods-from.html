---
layout: post
title: Extracting MSDS Finished Goods from MAPICS/38 using PL/1
date: '2012-05-02T22:51:00.001-04:00'
author: John Watson
excerpt: …a PL/1 program that walks down a manufactured product assembly chain for a finished good product and explodes out the complete list of raw materials that make up the product. I had to build a “shadow” bill of materials for each finished good item that consisted of the raw materials so I could then simulate chemical reactions and determine the remaining ingredients that were left...
tags:
- General
modified_time: '2012-05-02T22:51:30.456-04:00'
blogger_id: tag:blogger.com,1999:blog-2811308028656623966.post-7546966937689208911
blogger_orig_url: http://pragmatic-software.blogspot.com/2012/05/extracting-msds-finished-goods-from.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Okay, this has to take the cake for a rare combination…a PL/1 program that walks down a manufactured product assembly chain for a finished good product and explodes out the complete list of raw materials that make up the product. I had to build a “shadow” bill of materials for each finished good item that consisted of the raw materials so I could then simulate chemical reactions and determine the remaining ingredients that were left. If these ingredients were then above certain thresholds they have to be declared on a Material Safety Data Sheet. Wonder how it might look in C# in an OO style using today’s patterns?<br /><br /><pre>/*   MSD710P - Load a Product Structure into MSDS from PDM   */<br /><br /> MSD710P: PROCEDURE (BR_ITEM_IN) RETURNS(CHAR(2));<br /><br /> /********************************************************************/<br /> /*     NAME: MSD710P                                                */<br /> /*  PURPOSE: Load the Mapics/38 Product Structure into MSDS System  */<br /> /*  WRITTEN: 01/30/90                                               */<br /> /*   AUTHOR: John Watson                                            */<br /> /*   SYSTEM: IBM System/38                                          */<br /> /* LANGUAGE: PL/I                                                   */<br /> /* SECURITY: None                                                   */<br /> /*    DESCR: This pgm extracts the product structure of an item     */<br /> /*           from the Mapics/38 Product Structure file (PSTRUC)     */<br /> /*           and builds the MSDS Finished Good/Component file       */<br /> /*           (COMPNT).  Only final raw materials are output to the  */<br /> /*           MSDS system.  That is, phantoms and sub-assemblies are */<br /> /*           exploded down to their raw materials as well.  The raw */<br /> /*           material quantities are converted to pounds or gallons */<br /> /*           in a batch size of 100 (100 lbs / 100 gals) for the    */<br /> /*           100 Unit Formula used by the MSDS system.              */<br /> /*              NOTE:  This is designed as a function to            */<br /> /*                   FACILITATe returning to the caller             */<br /> /*                     with return codes.                           */<br /> /*                                                                  */<br /> /*   RETURN: 00 = Successful completion                             */<br /> /*           1x = Problem w/ finished good item                     */<br /> /*            0 =   Item A record not found                         */<br /> /*            1 =   Deleted Item A                                  */<br /> /*            2 =   Assembly chain not found                        */<br /> /*           2x = Problem w/ a component                            */<br /> /*            0 =   PSTRUC not found, assy chain broken/bad         */<br /> /*            1 =   component Item A record not found               */<br /> /*            2 =   RRNs don't match                                */<br /> /*            3 =   component Item A deleted                        */<br /> /*            4 =   compare portions don't match                    */<br /> /*            5 =   bad low level code (exceeds 99)                 */<br /> /*            6 =   MSFILM record not found - cannot convert qty    */<br /> /*                                                                  */<br /> /********************************************************************/<br /><br /> /* DECLARE FILES */<br /> DCL<br />  ITEMAKEY FILE RECORD INPUT DIRECT KEYED INTERNAL<br />             ENV(BUFSIZE(256) INDEXED KEYDISP(1) KEYLENGTH(16)),<br />  ITEMARRN FILE RECORD INPUT DIRECT ENV(BUFSIZE(256)) INTERNAL,<br />  ITEMAC   FILE RECORD INPUT DIRECT KEYED ENV(DESCRIBED INDEXED),<br />  PSTRUC   FILE RECORD INPUT DIRECT ENV(BUFSIZE(96)) INTERNAL,<br />  MSFILMPF FILE RECORD INPUT DIRECT KEYED ENV(DESCRIBED INDEXED),<br />  MSBSRMPF FILE RECORD SEQUENTIAL KEYED ENV(DESCRIBED INDEXED);<br /><br /> /* DECLARE RECORDS FOR INPUT FROM FILES */<br /><br /> DCL 1 COMPNT,<br />           %INCLUDE MSBSRMPF(COMPNT,RECORD);<br /> DCL 1 CFMT,<br />           %INCLUDE ITEMAC(CFMT,RECORD);<br /> DCL 1 RMFILM,<br />           %INCLUDE MSFILMPF(RMFILM,RECORD);<br />   /**************************************************/<br />   /* ITEMAS is internally described because we need */<br />   /* std batch qty of parent from pos. 244-249.     */<br />   /**************************************************/<br /> DCL 1 ITEMA_P,<br />       2  PR_ACREC  CHAR(1),    /* active record code                */<br />       2  PR_ITNBR  CHAR(15),   /* item number                       */<br />       2  PR_FILL1  CHAR(1),    /* filler 1                          */<br />       2  PR_IIREC  DEC(7,0),   /* RRN for this item                 */<br />       2  PR_LOLEV  PIC '9R',   /* low level code                    */<br />       2  PR_IIFAC  DEC(7,0),   /* RRN of first assembly component   */<br />       2  PR_FILL2  CHAR(105),  /* filler 2                          */<br />       2  PR_UNMSR  CHAR(2),    /* unit of measure                   */<br />       2  PR_ITTYP  CHAR(1),    /* item type                         */<br />       2  PR_FILL3  CHAR(108),  /* filler 3                          */<br />       2  PR_SBQTY  DEC(11,3),  /* standard batch quantity           */<br />       2  PR_FILL4  CHAR(7);    /* filler 4                          */<br /> DCL 1 ITEMA_C,<br />       2  PC_ACREC  CHAR(1),    /* active record code                */<br />       2  PC_ITNBR  CHAR(15),   /* item number                       */<br />       2  PC_FILL1  CHAR(1),    /* filler 1                          */<br />       2  PC_IIREC  DEC(7,0),   /* RRN for this item                 */<br />       2  PC_LOLEV  PIC '9R',   /* low level code                    */<br />       2  PC_IIFAC  DEC(7,0),   /* RRN of first assembly component   */<br />       2  PC_FILL2  CHAR(105),  /* filler 2                          */<br />       2  PC_UNMSR  CHAR(2),    /* unit of measure                   */<br />       2  PC_ITTYP  CHAR(1),    /* item type                         */<br />       2  PC_FILL3  CHAR(108),  /* filler 3                          */<br />       2  PC_SBQTY  DEC(11,3),  /* standard batch quantity           */<br />       2  PC_FILL4  CHAR(7);    /* filler 4                          */<br /> DCL 1 PSTRUCT,<br />       2  PPCIM     DEC(7,0),   /* component item A RRN              */<br />       2  PPPIM     DEC(7,0),   /* parent item "A" RRN               */<br />       2  PPNAC     DEC(7,0),   /* next assembly component RRN       */<br />       2  PPFIL1    CHAR(8),    /* filler 1                          */<br />       2  CCMPI     CHAR(1),    /* compare portion of item number    */<br />       2  PCOMP     CHAR(1),    /* compare portion of parent item    */<br />       2  PPFIL2    CHAR(16),   /* filler 2                          */<br />       2  EDATM     DEC(6,0),   /* effective from date               */<br />       2  EDATO     DEC(6,0),   /* effective to date                 */<br />       2  PPFIL3    CHAR(44),   /* filler 3                          */<br />       2  QTYPR     DEC(11,3);  /* quantity per unit                 */<br /><br /> /* DECLARE VARIABLES */<br /> DCL BATCH_SZ         DEC(7,3),  /* batch size */<br />     CMP(100)         CHAR(1),   /* compare characters */<br />     CMP_CHAR         CHAR(1),   /* compare character  */<br />     CNTRL_ID         CHAR(3),   /* used to redefine PPCIM */<br />     BR_ITEM_IN       CHAR(6),<br />     LVL              DEC(3,0),  /* array subscript */<br />     STD_BAT_QTY      DEC(11,3),<br />     RRN(100)         DEC(7,0),  /* RRNs to chase down assy chains   */<br />     REC_NO           DEC(7,0),  /* RRN workfield */<br />     SBQ(100)         DEC(11,3), /* Std batch qty for a given level  */<br />     WRK_QTY          FLOAT(7);<br /><br /> /* SYSTEM DATE */<br /> DCL CHR_DATE        CHAR(6),<br />     TST_DATE        DEC(6,0);    /* YYMMDD */<br /><br /> DCL 1 PROGRAM_FLAGS STATIC,<br />       2 NO                 BIT(1) ALIGNED INIT('0'B),<br />       2 YES                BIT(1) ALIGNED INIT('1'B),<br />       2 VALID_ITEM_A       BIT(1) ALIGNED,<br />       2 VALID_ITEM_C       BIT(1) ALIGNED,<br />       2 VALID_PSTRUC       BIT(1) ALIGNED,<br />       2 VALID_RMFILM       BIT(1) ALIGNED,<br />       2 MORE_COMPNT_RECS   BIT(1) ALIGNED;<br /><br /> /* OPEN FILES */<br /> OPEN FILE(ITEMAKEY);<br /> OPEN FILE(ITEMARRN);<br /> OPEN FILE(ITEMAC);<br /> OPEN FILE(MSFILMPF);<br /> OPEN FILE(PSTRUC);<br /><br /> /* ERROR HANDLING */<br /> ON KEY(ITEMAKEY) VALID_ITEM_A=NO;<br /> ON KEY(ITEMARRN) VALID_ITEM_A=NO;<br /> ON KEY(ITEMAC) VALID_ITEM_C=NO;<br /> ON KEY(PSTRUC) VALID_PSTRUC=NO;<br /> ON KEY(MSFILMPF) VALID_RMFILM=NO;<br /> ON KEY(MSBSRMPF) MORE_COMPNT_RECS=NO;<br /> ON ENDFILE(MSBSRMPF) MORE_COMPNT_RECS=NO;<br /><br /> %PAGE;<br /> /*    M A I N L I N E   */<br /><br /> CHR_DATE=DATE();<br /> TST_DATE=DECIMAL(CHR_DATE,6,0);<br /><br /> BATCH_SZ=100;<br /> LVL=1;<br /> RRN=0;<br /> SBQ=0;<br /> CMP=' ';<br /><br />    /* Get parent Item A */<br /><br /> VALID_ITEM_A=YES;<br /> READ FILE(ITEMAKEY) INTO(ITEMA_P) KEY(BR_ITEM_IN);<br /> SELECT;<br />   WHEN (VALID_ITEM_A=NO) RETURN('10');       /* record not found */<br />   WHEN (PR_ACREC='D') RETURN('11');          /* deleted record */<br />   WHEN (PR_IIFAC=9999999) RETURN('12');      /* no assembly chain */<br />   OTHERWISE;<br />   END;<br /> REC_NO=PR_IIFAC;<br /> STD_BAT_QTY=PR_SBQTY;<br /> CMP_CHAR=SUBSTR(PR_ITNBR,1,1);<br /><br />        /* Clear out old COMPNT records */<br /><br /> OPEN FILE(MSBSRMPF) UPDATE;<br /> MORE_COMPNT_RECS=YES;<br /> READ FILE(MSBSRMPF) INTO (COMPNT) KEY(BR_ITEM_IN);<br /> DO WHILE (MORE_COMPNT_RECS);<br />   DELETE FILE(MSBSRMPF);<br />   READ FILE(MSBSRMPF) INTO (COMPNT);<br />   IF BR_PARENTª=BR_ITEM_IN THEN MORE_COMPNT_RECS=NO;<br />   END;<br /> CLOSE FILE(MSBSRMPF);<br /> OPEN FILE(MSBSRMPF) OUTPUT;<br /><br />   /* begin down an assembly chain */<br /><br /> TOP:;<br /> RRN(LVL)=REC_NO;               /* point to first component */<br /> SBQ(LVL)=BATCH_SZ;             /* set batch size */<br /> CMP(LVL)=CMP_CHAR;             /* set compare values */<br /><br />   /* start of loop for next component */<br /><br /> CHAIN: DO UNTIL(REC_NO=9999999);<br /><br />       /* get next component */<br /><br />   VALID_PSTRUC=YES;<br />   READ FILE(PSTRUC) INTO(PSTRUCT) KEY(REC_NO);<br />   IF VALID_PSTRUC=NO THEN RETURN('20');<br />       /* check for control record */<br />   CNTRL_ID=CHAR(PPCIM,3);<br />   IF CNTRL_ID='.PS' THEN RETURN('20');<br />       /* check dates */<br />   IF (EDATM&gt;=TST_DATE) ³ (EDATOª=0 &amp; EDATO&lt;=TST_DATE) THEN DO;<br />      REC_NO=PPNAC;  /* outside dates - get next component */<br />      ITERATE CHAIN;<br />      END;<br /><br />      /* get component Item A */<br /><br />   VALID_ITEM_A=YES;<br />   READ FILE(ITEMARRN) INTO(ITEMA_C) KEY(PPCIM);<br />   SELECT;<br />     WHEN(VALID_ITEM_A=NO) RETURN('21');         /* no comp. Item A */<br />     WHEN(PC_IIRECª=PPCIM) RETURN('22');         /* RRNs don't match */<br />     WHEN(PC_ACREC='D') RETURN('23');            /* Item A deleted */<br />     WHEN(SUBSTR(PC_ITNBR,1,1)ª=CCMPI) RETURN('24'); /* compare char */<br />     WHEN(PC_LOLEV&gt;99) RETURN('25');              /* bad low level */<br />     OTHERWISE;<br />     END;<br /><br />      /* Check if this component is an intermediate. */<br />      /* If so, push current parent's values into    */<br />      /* arrays, set up work fields with new parent  */<br />      /* information and goto top to start down      */<br />      /* the chain of the new parent.                */<br /><br />   IF (PC_ITTYP='1') ³ (PC_IIFACª=9999999) THEN DO;<br />        /* save current parent values */<br />     RRN(LVL)=PPNAC;<br />     SBQ(LVL)=STD_BAT_QTY;<br />     CMP(LVL)=CMP_CHAR;<br />        /* set up work fields with new parent values */<br />     REC_NO=PPNAC;<br />     STD_BAT_QTY=PR_SBQTY;<br />     CMP_CHAR=SUBSTR(PC_ITNBR,1,1);<br />        /* increase current level */<br />     LVL=LVL+1;<br />     GOTO TOP;<br />     END;<br /><br />      /* get component Item C */<br /><br />   READ FILE(ITEMAC) INTO (CFMT) KEY(PC_ITNBR);<br /><br />      /* extend component qty &amp; convert to lbs */<br /><br />   WRK_QTY=BATCH_SZ/STD_BAT_QTY*QTYPR;<br />   SELECT;<br />      WHEN(PC_UNMSR='LB');<br />      WHEN(PC_UNMSR='GA') WRK_QTY=WRK_QTY*MC#GAL;<br />      WHEN(PC_UNMSR='GM') WRK_QTY=WRK_QTY/453.59;<br />      WHEN(PC_UNMSR='FL') WRK_QTY=(WRK_QTY*MC#GAL)/128;<br />      WHEN(PC_UNMSR='OZ') WRK_QTY=WRK_QTY/16;<br />      WHEN(PC_UNMSR='LY') DO;<br />        READ FILE(MSFILMPF) INTO(RMFILM) KEY(PC_ITNBR);<br />        IF VALID_RMFILM THEN DO;<br />          WRK_QTY=WRK_QTY*RF_WIDTH*RF_THICKNESS*.155844*MC#GAL;<br />          END;<br />        ELSE RETURN('26');   /* no MSFILMPF record */<br />        END;<br />      OTHERWISE;<br />      END;<br /><br />      /* write out COMPNT */<br /><br />   BR_COMP_QTY=WRK_QTY;<br />   BR_PARENT=BR_ITEM_IN;<br />   BR_COMPONENT=SUBSTR(PC_ITNBR,1,6);<br />   WRITE FILE(MSBSRMPF) FROM (COMPNT) KEYFROM(*);<br /><br />   REC_NO=PPNAC;<br /> END;  /* DO group */<br /><br />    /* At this point, we have reached the end of an  */<br />    /* assembly chain (PPNAC=9999999).  Check to see */<br />    /* if we encountered any intermediates along the */<br />    /* way.  If we did, pull back up one level and   */<br />    /* continue down the previous parent's chain.    */<br /><br /> DO WHILE(LVL&gt;1);<br />   LVL=LVL-1;<br />   IF RRN(LVL)ª=9999999 THEN DO;<br />     REC_NO=RRN(LVL);<br />     STD_BAT_QTY=SBQ(LVL);<br />     CMP_CHAR=CMP(LVL);<br />     GOTO CHAIN;<br />     END;<br />   END;<br /><br /> RETURN('00');   /* DONE! */<br /> END MSD710P;</pre></div>