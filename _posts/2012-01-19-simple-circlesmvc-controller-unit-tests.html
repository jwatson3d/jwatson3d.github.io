---
layout: post
title: Simple Circles–MVC Controller Unit Tests (Part 5)
date: '2012-01-19T06:00:00.000-05:00'
author: John Watson
excerpt: In the last post I left off with the PeopleController refactored to use an IPartyRepository via dependency injection. Now I’ll create unit tests for the controller so that we’ll know if something breaks as the solution evolves...
tags:
- Patterns
- MVC
- Tutorial
- TDD
- ASP.NET 4.0
- OSS
modified_time: '2012-01-20T08:03:33.174-05:00'
thumbnail: http://lh4.ggpht.com/-IXW0vyDGnIk/TxjhEmy9a6I/AAAAAAAAAt8/LvymwD__zl8/s72-c/Simple%252520Circles%252520-%252520ControllerTests_thumb%25255B1%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-2811308028656623966.post-7213416326305324341
blogger_orig_url: http://pragmatic-software.blogspot.com/2012/01/simple-circlesmvc-controller-unit-tests.html
---

<div style="text-align: left" dir="ltr" trbidi="on">This post is part of a <a href="http://pragmatic-software.blogspot.com/2012/01/simple-circlesintroduction.html">series</a> on building a simple to use web-based contact and customer relationship management application. The goal is to support various audiences including businesses, teams, clubs, religious organizations, etc.</div> <div style="text-align: left" dir="ltr" trbidi="on"><br><a href="http://lh4.ggpht.com/-YRDoS4lwAws/TxjhEbp6OjI/AAAAAAAAAt0/iEnzkrbfbqY/s1600-h/Simple%252520Circles%252520-%252520ControllerTests%25255B3%25255D.png"><img style="background-image: none; border-right-width: 0px; margin: 0px 0px 0px 3px; padding-left: 0px; padding-right: 0px; display: inline; float: right; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Simple Circles - ControllerTests" border="0" alt="Simple Circles - ControllerTests" align="right" src="http://lh4.ggpht.com/-IXW0vyDGnIk/TxjhEmy9a6I/AAAAAAAAAt8/LvymwD__zl8/Simple%252520Circles%252520-%252520ControllerTests_thumb%25255B1%25255D.png?imgmax=800" width="144" height="162"></a>In the <a href="http://pragmatic-software.blogspot.com/2012/01/simple-circlesadd-aspnet-mvc-3-ui-part_15.html">last post</a> I left off with the <span style="font-family: courier new">PeopleController</span> refactored to use an <span style="font-family: courier new">IPartyRepository</span> via dependency injection. Now I’ll create unit tests for the controller so that we’ll know if something breaks as the solution evolves. Since I’m planning on several views and controllers, I added a <span style="font-family: courier new">ControllerTests</span> folder to the <span style="font-family: courier new">UnitTests</span> project to organize and group them together. With <a href="http://xunit.codeplex.com/" target="_blank">xUnit</a>, as with many unit testing frameworks, simply add a new class called <span style="font-family: courier new">PeopleControllerTest</span> and begin writing the tests.</div> <div style="text-align: left" dir="ltr" trbidi="on"><br>Unit testing MVC controllers generally falls into two categories:</div> <div style="text-align: left" dir="ltr" trbidi="on"> <ol> <li>Ensuring that an action result being returned from a controller’s action is correct. On HTTP GET requests, this means the correct view result is returned.  <li>Ensuring that HTTP POSTs are behaving properly:  <ol style="list-style-type: lower-alpha"> <li>A POST with purposely invalid model data causes it to route the request back to the originating view.  <li>A POST with correct model data causes it to route back to the Index view.</li></ol></li></ol></div>Because of the dependency injection work just done, setting up the unit test is straightforward:<br><pre class="c-sharp" name="code">[Fact]<br>public void DefaultGetReturnsIndexView()<br>{<br>  // arrange<br>  const string ExpectedViewName = "Index";<br>  var peopleController = <br>        new PeopleController(new FakeRepository.FakePartyRepository());<br><br>  // act<br>  var viewResult = peopleController.Index();<br><br>  // assert<br>  Assert.NotNull(viewResult);<br>  Assert.Equal(ExpectedViewName, viewResult.ViewName);<br>  var model = viewResult.ViewData.Model as IEnumerable<person>;<br>  Assert.NotNull(model);<br>}</person></pre><br /><p>Notice on Line #6 above that it’s easy to pass a new instance of the <span style="font-family: courier new">FakeRepository</span> from the test method. The assertions section checks that a view result was returned, that it was the expected named view result and that the view’s model is present.</p><br /><p>Testing the HTTP POST actions is a bit more involved. The basic test is the same however since the testing class is calling the controller directly a little more work is needed. Model validation is a part of the MVC runtime which is not present during testing so it is necessary to “prime the pump” so to speak by placing the error into the controller’s <span style="font-family: courier new">ModelState</span> to see if it’s being handled correctly – this is essentially the same behavior the MVC runtime exhibits:</p><pre class="c-sharp" name="code">[Fact]<br>public void CreatePostReturnsViewIfModelStateIsInvalid()<br>{<br>  // arrange<br>  const string ExpectedViewName = "Create";<br>  var peopleController<br>        = new PeopleController(new FakeRepository.FakePartyRepository());<br>  peopleController.ModelState.AddModelError("LastName", "LastName is required.");<br>  var person = new Person<br>      {<br>        FirstName = "Henry",<br>        MiddleName = "Lewis",<br>        //LastName = "Stimson ",<br>        Gender = Enum.GetName(typeof(GenderEnum), GenderEnum.Male),<br>        Birthday = new DateTime(1867, 9, 21)<br>      };<br><br>  // act<br>  var viewResult = peopleController.Create(person) as ViewResult;<br><br>  // assert<br>  Assert.NotNull(viewResult);<br>  Assert.Equal(ExpectedViewName, viewResult.ViewName);<br>}</pre><br /><p>Line #8 above is where the error is set up. Lines #9 through #16 create a <span style="font-family: courier new">Person</span> instance to pass to the controller method to mimic what the MVC runtime will do. Notice that I commented out the line for setting the <span style="font-family: courier new">LastName</span> property for authenticity purposes. Personally, I would hate to come across some else’s code that sets up an error yet passes in perfectly valid data. Finally, the assert statements check that the same <span style="font-family: courier new">Create</span> view is returned indicating that the error(s) were detected and handled properly.<br><br>Testing for a valid model is nearly the same – just don’t set the <span style="font-family: courier new">ModelState</span>, pass a valid <span style="font-family: courier new">Person</span> instance and check that we’re returned to the Index page. Edit, update and delete actions are nearly identical as well.</p><br /><p>The final bit of code worthy of mention is around the use of <a href="http://automapper.org/" target="_blank">AutoMapper</a> – remember that the <a href="http://pragmatic-software.blogspot.com/2012/01/simple-circlesadd-aspnet-mvc-3-ui-part_15.html">last post</a> introduced AutoMapper as an implementation of the DataMapper pattern. I wired up the mapping initialization inside <font face="Courier New">Global.asax.cs</font> then. Of course the test harness doesn’t have a website since it’s job is exercising the logic and behavior of the controller classes. Therefore I have to use the xUnit way of introducing a “fixture” necessary for the test class to operate.</p><pre class="c-sharp" name="code">public class PeopleControllerTest : IUseFixture&lt;DataMapperFixture&gt;<br />{<br />  public void SetFixture(DataMapperFixture data)<br />  {<br />    data.CreateMaps();<br />  }<br />  ...<br />}<br />...<br />public class DataMapperFixture : IDisposable<br />{<br />  public void CreateMaps()<br />  {<br />    Mapper.AssertConfigurationIsValid();<br />    PersonMap.CreateMaps();<br />  }<br />}</pre><br /><p>The test class implements the xUnit <font face="Courier New">IUseFixture&lt;T&gt;</font> interface which tells the xUnit runtime that it needs to call <font face="Courier New">SetFixture</font> with an instance of that type – in my case I created a trivial <font face="Courier New">DataMapperFixture</font> class that simply verifies the mapping is valid and calls the <font face="Courier New">PersonMap.CreateMaps()</font> method to initialize <font face="Courier New">AutoMapper</font>.</p><br /><p>The source code for this article can be downloaded from <a href="http://simplecircles.codeplex.com/SourceControl/changeset/changes/9951d0cc21a4" target="_blank">here</a>. The next installment will explore some simple jQuery enhancements to make the UI a little nicer and more informative. </p>  